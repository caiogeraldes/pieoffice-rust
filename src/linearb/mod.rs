use aegean_numerals_rs::UAegean;
use lazy_static::lazy_static;
use std::collections::HashMap;

const ENTRY_VALUES: [&str; 222] = [
    "-", "*132", "*142", "*146", "*150", "*152", "*153", "*154", "*155", "*157", "*158", "*160",
    "*161", "*164", "*165", "*166", "*167", "*168", "*169", "*170", "*171", "*172", "*174", "*177",
    "*178", "*179", "*180", "*18", "*181", "*182", "*183", "*184", "*185", "*189", "*190", "*19",
    "*200", "*201", "*202", "*203", "*204", "*205", "*206", "*207", "*208", "*209", "*210", "*211",
    "*212", "*213", "*214", "*215", "*216", "*217", "*218", "*219", "*220", "*221", "*222", "*226",
    "*227", "*228", "*229", "*22", "*232", "*234", "*236", "*245", "*246", "*248", "*249", "*250",
    "*251", "*252", "*253", "*255", "*256", "*257", "*258", "*259", "*305", "*34", "*47", "*49",
    "*56", "*63", "*64", "*65", "*79", "*82", "*83", "*86", "*89", "AES", "ALVEUS", "ARBOR",
    "AREPA", "ARMA", "AROM", "AUR", "BIGAE", "BOSf", "BOSm", "CAPSUS", "CAPf", "CAPm", "CERV",
    "CORNU", "CURRUS", "CYP", "DIPTE", "EQUf", "EQUm", "EQU", "GALEA", "GRA", "HASTA", "HORD",
    "JACULUM", "KANAKO", "KAPO", "LANA", "LUNA", "MERI", "MUL", "OLE", "OLIV", "OVISf", "OVISm",
    "PUGIO", "ROTA", "SAGITTA", "SUSf", "SUSm", "TELA", "TUNICA", "TURO2", "VIN", "VIR", "da",
    "de", "di", "do", "du", "dwe", "dwo", "je", "jo", "ju2", "ju", "ka", "ke", "ki", "ko", "ku",
    "ma", "me", "mi", "mo", "mu", "na", "ne", "ni", "no", "nu", "nwa", "ja", "pa", "pe", "pi",
    "po", "pte", "pu2", "pu", "qa", "qe", "qi", "qo", "ra2", "ra3", "ra", "re", "ri", "ro2", "ro",
    "ru", "sa", "se", "si", "so", "su", "ta2", "ta", "te", "ti", "to", "tu", "two", "u", "wa",
    "we", "wi", "wo", "za", "ze", "zo", "e", "a2", "a3", "a", "i", "o", "g,", "V", "M", "N", "T",
    "P", "Q", "L", "S", "Z",
];

const UNI_VALUES: [&str; 222] = [
    "", "ğ‚—", "ğ‚œ", "ğ‚", "ğ‚Ÿ", "ğ‚¡", "ğ‚¢", "ğ‚£", "ğƒ", "ğ‚¥", "ğ‚¦", "ğ‚¨", "ğ‚©", "ğ‚¬", "ğ‚­", "ğ‚®", "ğ‚¯", "ğ‚°", "ğ‚±",
    "ğ‚²", "ğ‚³", "ğ‚´", "ğ‚¶", "ğ‚¸", "ğ‚¹", "ğ‚º", "ğ‚»", "ğ", "ğ‚¼", "ğ‚½", "ğ‚¾", "ğ‚¿", "ğƒ€", "ğƒ", "ğƒ‚", "ğ‘", "ğƒŸ", "ğƒ ",
    "ğƒ¡", "ğƒ¢", "ğƒ£", "ğƒ¤", "ğƒ¥", "ğƒ¦", "ğƒ§", "ğƒ¨", "ğƒ©", "ğƒª", "ğƒ«", "ğƒ¬", "ğƒ­", "ğƒ®", "ğƒ¯", "ğƒ°", "ğƒ±", "ğƒ²", "ğƒ„",
    "ğƒ³", "ğƒ´", "ğƒµ", "ğƒ¶", "ğƒ·", "ğƒ¸", "ğ’", "ğƒˆ", "ğƒŠ", "ğƒ‹", "ğƒ", "ğƒ‘", "ğƒ“", "ğƒ”", "ğƒ¹", "ğƒ•", "ğƒ–", "ğƒ—", "ğƒ™",
    "ğƒš", "ğƒ›", "ğƒœ", "ğƒ", "ğƒº", "ğ“", "ğ”", "ğ•", "ğ–", "ğ—", "ğ˜", "ğ€", "ğ™", "ğš", "ğ›", "ğœ", "ğ", "ğ‚š", "ğƒ…",
    "ğ‚·", "ğ‚˜", "ğ‚«", "ğ‚‘", "ğ‚›", "ğƒŒ", "ğ‚Œ", "ğ‚", "ğƒ", "ğ‚ˆ", "ğ‚‰", "ğ‚‚", "ğ‚ ", "ğƒ", "ğ‚’", "ğƒ’", "ğ‚„", "ğ‚…", "ğ‚ƒ",
    "ğƒƒ", "ğ‚", "ğƒ†", "ğ‚", "ğƒ˜", "ğ‚”", "ğ‚“", "ğ‚", "ğ‚µ", "ğ‚™", "ğ‚", "ğ‚•", "ğ‚", "ğ‚†", "ğ‚‡", "ğƒ‰", "ğƒ", "ğƒ‡", "ğ‚Š",
    "ğ‚‹", "ğ‚§", "ğ‚ª", "ğ‚¤", "ğ‚–", "ğ‚€", "ğ€…", "ğ€†", "ğ€‡", "ğ€ˆ", "ğ€‰", "ğƒ", "ğ„", "ğ€‹", "ğ€", "ğ€", "ğ€", "ğ€", "ğ€",
    "ğ€‘", "ğ€’", "ğ€“", "ğ€”", "ğ€•", "ğ€–", "ğ€—", "ğ€˜", "ğ€™", "ğ€š", "ğ€›", "ğ€œ", "ğ€", "ğ…", "ğ€Š", "ğ€", "ğ€Ÿ", "ğ€ ", "ğ€¡",
    "ğ‡", "ğ†", "ğ€¢", "ğ€£", "ğ€¤", "ğ€¥", "ğ€¦", "ğˆ", "ğ‰", "ğ€¨", "ğ€©", "ğ€ª", "ğŠ", "ğ€«", "ğ€¬", "ğ€­", "ğ€®", "ğ€¯", "ğ€°",
    "ğ€±", "ğŒ", "ğ€²", "ğ€³", "ğ€´", "ğ€µ", "ğ€¶", "ğ", "ğ€„", "ğ€·", "ğ€¸", "ğ€¹", "ğ€º", "ğ€¼", "ğ€½", "ğ€¿", "ğ€", "ğ€", "ğ",
    "ğ€€", "ğ€‚", "ğ€ƒ", "ğ„€", "ğ„¾", "ğ„¸", "ğ„¹", "ğ„¼", "ğ„º", "ğ„»", "ğ„·", "ğ„½", "ğ„¿",
];

lazy_static! {
    static ref ENTRY_TO_UNI: HashMap<&'static str, &'static str> = {
        let mut m = HashMap::new();
        for (b, u) in ENTRY_VALUES.iter().zip(UNI_VALUES.iter()) {
            m.insert(*b, *u);
        }
        m
    };
}

fn ascii_to_unicode<T: Into<String>>(input: T) -> String {
    let mut output: String = input.into();
    ENTRY_VALUES.iter().for_each(|c| {
        output = output.replace(*c, ENTRY_TO_UNI.get(c).unwrap());
    });

    output
}

fn numbers<T: Into<String>>(input: T) -> String {
    let output = input.into();

    let vecoutput = output
        .split(' ')
        .map(|st: &str| match st.parse::<u32>() {
            Ok(v) => UAegean::new(v).unwrap().into_aegean(),
            Err(_) => st.to_owned(),
        })
        .collect::<Vec<String>>();
    vecoutput.join(" ")
}

pub fn convert<T: Into<String>>(input: T) -> String {
    let mut output = input.into();
    output = ascii_to_unicode(output);
    output = numbers(output);
    output
}
